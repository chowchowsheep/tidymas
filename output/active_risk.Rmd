---
title: "SAT Active Risk Report"
output:
  word_document:
    reference_docx: ref_format.docx
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(tidyverse)
library(Rblpapi)
library(pbapply)
library(lubridate)
library(RcppRoll)
library(scales)
library(knitr)

blpConnect()
```

```{r initialize}
# Get strategies from file and their sizes (mix of month weighted and %)
strategies_list <- build_strategies("../data2/strategies.csv")

# Get required instruments and portfolios (actual vs sim)
instr_df <- strategies_list$summary
portfolios_list <- strategies_list[names(strategies_list) != "summary"]

# Get duration from Bloomberg
dur_df <- get_dur_bbg(instr_df)

# Calculate all weights in %
clean_pf_list <- map(portfolios_list, 
                  ~convert_dur_size(., instr_df, dur_df))

# Get returns of assets from Bloomberg
asset_returns <- get_ret_bbg(instr_df)

# Calculate weight return of strategies
wt_returns <- map(clean_pf_list, 
                  ~calc_strat_wt_return(., asset_returns))

# Calculate weight of strategies
strat_headline_size <- map(clean_pf_list, 
                           ~calc_strat_headline_size(.))

# Calculate unweighted return of strategies
unwt_returns <- map2(wt_returns, strat_headline_size, calc_strat_unwt_return)

# Calculate active risk of current strategies
active_risk <- calc_active_risk(unwt_returns$sim, 
                                get_strat_size(strat_headline_size$actual, as.Date("2018-11-28")),
                                start_date = as.Date("2017-11-28"), end_date = as.Date("2018-11-28"))

# Calculate active risk of previous quarters strategies 
active_risk_lastq <- calc_active_risk(unwt_returns$sim, 
                                get_strat_size(strat_headline_size$actual, as.Date("2018-08-28")),
                                start_date = as.Date("2017-08-28"), end_date = as.Date("2018-08-28"))
```

```{r get_scenarios}
scenarios_input <- read.csv("../data2/scenarios.csv", stringsAsFactors = FALSE) %>%
  mutate(start_date = ymd(start_date),
         end_date = ymd(end_date))

# Add permanent series of most recent quarter
scenarios <- rbind(scenarios_input, 
      data.frame(period = c("Last3M"), start_date = c(today() - months(3)), end_date = c(as.Date(NA))))

# Order by last 3M, then based on start dates (for plotting purposes)
ordered_periods <- c("Last3M", scenarios$period[order(scenarios$start_date)][!scenarios$period[order(scenarios$start_date)] %in% c("Last3M")])
```

```{r calc_team_correlation_analysis}
# Calculate team returns by summing returns across strategies within each division
team_ret <- sim_ret %>% 
  rownames_to_column("date") %>%
  gather(strategy, return, -date) %>%
  left_join(strategies %>% select(strategy, owner), 
            by = "strategy") %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  group_by(date, owner) %>%
  summarise(return = sum(return, na.rm = T)) %>% 
  spread(owner, -date)

# Calculate correlation between teams, see helper.R for calc_cor()
team_cor <- calc_cor(team_ret, 
                     start_date = scenarios %>% filter(period == "Last3M") %>% .$start_date) 

```

```{r write_up}
###################################################
# Start generation of report, starting with writeup
###################################################

# Parameters to be displayed in later section
risk_budget <- 80
current_quarter <- month(today()) %/% 3 + 1
prev_quarter <- if (month(today()) %/% 3 == 0) 4 else month(today()) %/% 3
current_active_risk <- active_risk_all$Last3M %>% abs %>% sum * 10000
prev_active_risk <- prev_strat_active_risk
info_ratio <- 0.3
gfc_active_risk <- active_risk_all$GFCStress %>% abs %>% sum * 10000
taper_active_risk <- active_risk_all$TaperTantrum %>% abs %>% sum * 10000

# Find highest active risk strategy
top_strategy <- active_risk_all %>% select(strategy, Last3M) %>% arrange(desc(Last3M)) %>% head(1)
top_strategy_risk <- top_strategy$Last3M / sum(active_risk_all$Last3M)
top_strategy_name <- top_strategy$strategy %>% str_extract("^.*(?=:::)")
top_strategy_owner <- top_strategy$strategy %>% 
  str_extract("(?<=:::).*$") %>%
  toupper
top_strategy_type <- strategies %>% filter(strategy == top_strategy$strategy) %>% .$type

# Find most diversifying strategy
most_diverse <- active_risk_all %>% select(strategy, Last3M) %>% arrange(desc(Last3M)) %>% tail(1)
most_diverse_risk <- most_diverse$Last3M / sum(active_risk_all$Last3M)
most_diverse_name <- most_diverse$strategy %>% str_extract("^.*(?=:::)")
most_diverse_owner <- most_diverse$strategy %>%
  str_extract("(?<=:::).*$") %>%
  toupper

# Format active risk table (by strategies)
strat_active_risk <- active_risk_all %>% 
  select(strategy, Last3M) %>% 
  left_join(strategies %>% select(strategy, owner, asset_class, type) %>% unique, by = "strategy")

# Calculate active risk by division
div_risk <- strat_active_risk %>%
  group_by(owner) %>%
  summarise(Last3M = sum(abs(Last3M))) %>%
  ungroup %>%
  mutate(risk_percent = Last3M / sum(Last3M),
         owner = toupper(owner)) %>%
  arrange(desc(risk_percent))

```

**The RMD ex BW active risk utilization for Q`r current_quarter` is expected to be around `r sprintf("%.1f", current_active_risk)`bps in our baseline scenario**, `r if (current_active_risk > risk_budget) "above" else "below"` the available risk budget for FY18/19 and `r if (current_active_risk > prev_active_risk) "above" else "below"` our estimates for the last quarters (`r prev_quarter`Q: `r sprintf("%.1f",prev_strat_active_risk)`bps). Assuming an information ratio of `r sprintf("%.1f", info_ratio)`, the expected portfolio excess return will be `r sprintf("%.1f", info_ratio * current_active_risk)` (annualized). Under a stress scenario similar to the GFC and the Taper Tantrum, we expect active risk utilization to increase to around `r sprintf("%.1f", gfc_active_risk)` and `r sprintf("%.1f", taper_active_risk)`bps respectively

**Key observations are: **

1. `r top_strategy_owner`'s `r top_strategy_type` strategy of `r top_strategy_name` constitutes the highest active risk. The trade has an active risk of `r sprintf("%.1f", top_strategy$Last3M * 10000)`bps, which is `r sprintf("%.1f", top_strategy_risk * 100)`% of total active risk

2. The most diversifying strategy in the portfolio is the `r most_diverse_name` from the `r most_diverse_owner`, with a `r sprintf("%.1f", most_diverse_risk * 100)`% risk contribution

3. Risk contribution across the different divisions are shown below. `r div_risk$owner[1]` accounts for bulk of total risk at `r sprintf("%.1f", div_risk$risk_percent[1] * 100)`%, followed by `r div_risk$owner[2]` and `r div_risk$owner[3]` at `r sprintf("%.1f", div_risk$risk_percent[2] * 100)`% and `r sprintf("%.1f", div_risk$risk_percent[3] * 100)`% respectively. 

### Current Active Strategies

```{r display_strategies}
# Find current weight
wt_df <- data.frame(size_percent = t(curr_wt)) %>% 
  rename(size_percent = 1) %>% 
  rownames_to_column("strategy") 

# Process and print strategies
strategies %>%                                                         # Get strategies
  filter(strategy %in% active_strategies & is.na(close_date)) %>%      # Filter strategies still open
  group_by(owner, strategy, type, size_type, instrument) %>%           # Sum up trade sizes for each strategies' instrument
  summarise(size = sum(size)) %>%
  group_by(owner, type, strategy, size_type) %>%                       # Find size of trade by taking the max (in case of long short)
  summarise(size = max(size)) %>%
  left_join(wt_df, by = "strategy") %>%                                # Add current weight of each strat to the table
  left_join(active_risk_all %>% select(strategy, active_risk = Last3M), by = "strategy") %>%  # Add active risk
    ungroup %>%                             
  mutate(active_risk_percent = active_risk / sum(active_risk),         # Calculate % of active risk, and reformat active risk in bps 
         active_risk = active_risk * 10000) %>%
    ungroup %>%
  arrange(desc(active_risk)) %>%                                       # Sort strategies in descending by active risk
  mutate(input_size = str_replace(sprintf("%.2f %s", size, size_type)," percent","%") %>% str_replace(" months", "m"),  # Format numbers
         size_percent = scales::percent(size_percent,accuracy = 0.01),
         active_risk = scales::number(active_risk, accuracy = 0.1),
         active_risk_percent = scales::percent(active_risk_percent, accuracy = 0.1)) %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)"),               # Format naming of strategy to remove division, add serial number
         no = 1:nrow(.)) %>%
  select(no, strategy, owner, type, input_size, size_percent, active_risk, active_risk_percent) %>%   # Select required fields for display
  rename("active_risk (bps)" = "active_risk",                          # Format headers of the table
         "active_risk (% R2)" = "active_risk_percent") %>% 
  kable                                                                # Display table
  
```

## Active Risk

*Active risk contribution is the contribution to total standard deviation of the portfolio. Individual trades' active risk is additive to form overall portfolio standard deviation aka active risk of the portfolio*

```{r display_active_risk, fig.width = 9, fig.height = 4}
# Find order of strategies by their risk contribution in the last 3m (for plotting purposes)
ordered_strategies <- select(active_risk_all, strategy, Last3M)  %>%
  rename(active_risk = "Last3M") %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  group_by(strategy) %>%
  summarise(active_risk = sum(active_risk)) %>%
  ungroup %>%
  mutate(order = order(active_risk)) %>%
  arrange(active_risk) %>%
  .$strategy

# Formating active risk for display and to fit into ggplot
active_risk_gathered <- active_risk_all %>%
  left_join(unique(select(strategies, strategy, owner, type)), by = "strategy") %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  mutate(strategy = factor(strategy, level = ordered_strategies),
         owner = factor(owner, level = c("us", "cat", "europe", "ed"))) %>%
  gather(period, active_risk, -strategy, -owner, -type) %>%
  mutate(period = factor(period, level = ordered_periods))

# Plot active risk by strategy
ggplot(active_risk_gathered, aes(x = strategy, y = active_risk * 10000, fill = owner)) + 
  geom_col() +
  facet_wrap(~period, ncol = 3) +
  labs(y = "active risk (bp)", title = "Active Risk by Strategy") +
  coord_flip() 
```
```{r display_active_risk_2, fig.width = 9, fig.height = 2}
# Plot active risk by asset strategies
active_risk_gathered %>% 
  group_by(period, type) %>%
  summarise(active_risk = sum(abs(active_risk))) %>%
  sort_gg("type", "active_risk") %>%
  ggplot(aes(x = type, y = active_risk * 10000)) + 
  geom_col() +
  facet_wrap(~period, ncol = 3) +
  labs(y = "active risk (bp)", title = "Active Risk by Strategy Types") +
  coord_flip() 

# Plot active risk by asset class
asset_types <- data.frame(type = c("Curve", "Inflation", "Duration", "Spread", "FX", "Equity"), 
                          asset_class = c("Fixed Income", "Fixed Income", "Fixed Income", "Fixed Income", "FX", "Equity"), 
                          stringsAsFactors = FALSE) 

active_risk_gathered %>% 
  left_join(asset_types, by = "type") %>%
  mutate(asset_class = ifelse(is.na(asset_class), "Others", asset_class)) %>%
  group_by(period, asset_class) %>%
  summarise(active_risk = sum(abs(active_risk))) %>%
  sort_gg("asset_class", "active_risk") %>%
  ggplot(aes(x = asset_class, y = active_risk * 10000)) + 
  geom_col() +
  facet_wrap(~period, ncol = 3) +
  labs(y = "active risk (bp)", title = "Absolute Active Risk by Asset Class") +
  coord_flip() 

# Plot active risk by division
active_risk_gathered %>% 
  group_by(period, owner) %>%
  summarise(active_risk = sum(abs(active_risk))) %>%
  sort_gg("owner", "active_risk") %>%
  ggplot(aes(x = owner, y = active_risk * 10000)) + 
  geom_col() +
  facet_wrap(~period, ncol = 3) +
  labs(y = "active risk (bp)", title = "Absolute Active Risk by Division") +
  coord_flip() 
```


```{r calc_sharpe}
# Find unique_strategies
unique_strategies <- strategies %>%
  select(strategy, owner, type) %>%
  unique

# Start date for calculation of returns
start_date_returns <- as.Date("2018-01-01")

# Extract return data based on start_date
actual_ret_filtered <- actual_ret %>% 
  rownames_to_column("date") %>%
  filter(date > start_date_returns) %>%
  gather(strategy, pnl, -date) %>%
  left_join(unique_strategies, by="strategy")
 
# Calculate sharpe grouped by owner, in annualized bps of R2
sharpe_by_owner <- actual_ret_filtered %>% 
  group_by(owner) %>%
  summarise(return = mean(pnl, na.rm = T) * 250 * 10000, 
            std_dev = sd(pnl, na.rm = T) * sqrt(250) * 10000) %>%
  mutate(sharpe = round(return / std_dev ,2),
         return = round(return, 2),
         std_dev  = round(std_dev , 2)) 

# Calculate sharpe grouped by strategy, in annualized bps of R2
sharpe_by_strategy <- actual_ret_filtered %>%
  group_by(type) %>%
  summarise(return = mean(pnl, na.rm = T) * 250 * 10000, 
            std_dev  = sd(pnl, na.rm = T) * sqrt(250) * 10000) %>%
  mutate(sharpe = round(return / std_dev , 2),
         return = round(return, 2),
         std_dev  = round(std_dev , 2))
```

## Sharpe Ratio

*Sharpe Ratio = Return / Std_dev*

*The returns and standard deviation below have been computed as annualized return in weighted basis points of R2.*

### 2018 Year-to-Date

#### By division
`r kable(sharpe_by_owner)`

#### By strategy types
`r kable(sharpe_by_strategy)`

#### Sharpe ratio breakdown by division

```{r display_sharpe, fig.width = 9}
# Breakdown components of sharpe (return and standard dev)
sharpe_breakdown <- actual_ret_filtered %>%
  group_by(owner, strategy, type) %>%
  summarise(std_dev = sd(pnl, na.rm = T) * sqrt(250) * 10000,
            return = mean(pnl, na.rm = T) * 250 * 10000) %>%
  ungroup %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  arrange(owner, return) %>%
  mutate(strategy = factor(strategy, levels = unique(strategy)))

# Plot breakdown of returns
sharpe_breakdown %>% 
  ggplot(aes(x = strategy, y = return)) + 
  geom_col() + 
  facet_wrap(~owner, ncol = 2, scales = "free_y") + 
  coord_flip() +
  labs(title = "Return contribution of trades (bps of R2, annualized)")

# Sort by standard deviation
sharpe_breakdown2 <- sharpe_breakdown %>%
  arrange(owner, std_dev) %>%
  mutate(strategy = factor(strategy, levels = unique(strategy))) 

# Plot breakdown of standard deviation
sharpe_breakdown2 %>% ggplot(aes(x = strategy, y = std_dev)) + 
  geom_col() + 
  facet_wrap(~owner, ncol = 2, scales = "free_y") + 
  coord_flip() +
  labs(title = "Std dev of trades (bps of R2, annualized)")
```

## Correlations

### Team Correlations

```{r display_correlation}
# Plot correlation of returns between teams
team_cor %>%
  plot_cor(title = NULL)
```

### Strategy Correlations

```{r display_corr_heatmap, fig.width = 9, fig.height = 5}
# Plot correlation of returns between strategies

#Find strategies ordered by owner name (for plotting purposes)
ordered_strategies <- strategies %>% select(strategy, owner) %>%
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  arrange(owner, strategy) %>%
  .$strategy %>%
  unique

# Extract unweighted return of all strategies still open
uniq_unwt_ret <- unwt_ret[,c("date", active_strategies)] %>%
  gather(strategy, return, -date) %>% 
  mutate(strategy = str_extract(strategy, "^.*(?=:::)")) %>%
  unique %>% 
  spread(strategy, -date) 

# Calculate correlation between all open trades across all scenarios
strat_cor_all <- bind_rows(
  apply(scenarios, 1,  # "Loop" through all scenarios
        function(x)
          # Calculate correlation for each  scenario
          calc_cor(uniq_unwt_ret, start_date = x['start_date'], end_date = x['end_date'], period_name = x['period']))) %>%
  mutate(strat1 = factor(strat1, levels = ordered_strategies),   # Order strategies for plotting
         strat2 = factor(strat2, levels = ordered_strategies))

# Plot all correlation matrices
for (i in rev(unique(strat_cor_all$period))) {
  cor_df <- strat_cor_all %>% filter(period == i)
  plot_cor(cor_df,  paste("Correlation during", i))
}

```

## Performance of strategies

### Actual returns (Cumulative Rolling 12 months)

```{r display_actual_ret, fig.width = 9}
# Plot actual returns, starting from start_date_returns, defined when calculating sharpe ratio
actual_ret_filtered <- actual_ret %>%
  rownames_to_column("date") %>%
  filter(date > start_date_returns) %>%
  column_to_rownames("date")

actual_ret_filtered[is.na(actual_ret_filtered)] <- 0    # Set all NAs to 0, to facilitate summing

# Find cumulative sum of returns
actual_ret_cum <- actual_ret_filtered %>%               
  mutate_all(funs(cumsum)) %>% 
  mutate(date = as.Date(rownames(actual_ret_filtered)))

# Format cumulative return for plotting  
actual_ret_cum_gathered <- actual_ret_cum %>%
  gather(strategy, cum_pnl, -date) %>%
  mutate(owner = str_extract(strategy, "(?<=:::).*$"),
         strategy = str_extract(strategy, "^.*(?=:::)"),
         cum_pnl = cum_pnl * 10000) 

# Plot cumulative return, one chart for each owner
results <- lapply(unique(actual_ret_cum_gathered$owner), function(i) {
  g <- actual_ret_cum_gathered %>% 
    filter(owner == i) %>%                                  # Filter returns from current owner
    ggplot(aes(x = date, y = cum_pnl)) +       
    geom_area(aes(fill = strategy)) +                       # Plot area chart
    stat_summary(fun.y = sum, geom = "line", size = 1) +    # Plot total line 
    labs(y = "Cumulative Pnl (R2 wt bps)", title = i) +
    theme(axis.title.x = element_blank(), legend.position = "bottom")
  print(g)
})
```

### Historical simulated returns profile of strategies

Below are 3 month returns arising from current strategies extrapolated into history. Higher intensive of green/red indicates a larger positive profit/loss over a 3 month period, while white indicates no significant PnL impact. Grey indicates the underlying instrument/s was not available during the period

*Unweighted return is the strategy's return over its own notional size. For curve trades, the notional of the higher duration leg is taken to be the trade size. This allows us to have an idea how each strategy would have performed over different periods in history*

```{r display_returns_over_time, fig.width = 9}
window = 20 * 3
######################################
#  Compute rolling 3 month returns
######################################

unwt_ret_roll <- apply(remove_date(unwt_ret), 2, roll_sum, n = window) %>% as.data.frame
unwt_ret_roll <- cbind(data.frame(date = unwt_ret$date[-(1:(window-1))]), unwt_ret_roll)

sim_ret2 <- sim_ret %>% rownames_to_column("date") %>%
  mutate(date = as.Date(date))
sim_ret_roll <- apply(remove_date(sim_ret2), 2, roll_sum, n = window) %>% as.data.frame
sim_ret_roll <- cbind(data.frame(date = sim_ret2$date[-(1:(window-1))]), sim_ret_roll)

######################################
# Plot heatmap of returns across time
######################################

active_unwt_ret_roll <- unwt_ret_roll[,c("date", active_strategies)]

max_ret_unwt <- max(remove_date(active_unwt_ret_roll), na.rm = T)
min_ret_unwt <- min(remove_date(active_unwt_ret_roll), na.rm = T)

# Adjusting x-axis to display dates properly
recalc_date <- active_unwt_ret_roll %>% 
  select(date) %>%
  mutate(yr = year(date), factored_date = as.factor(date)) %>%
  group_by(yr) %>%
  mutate(first_day = min(date)) %>%
  ungroup %>%
  mutate(new_date = ifelse(first_day == date & yr > 1994, sprintf("%02d", yr %% 100), ""),
         row_date = row_number()) %>%
  filter(new_date != "")
  
break_positions <- which(recalc_date$new_date != "")
date_labels <- recalc_date %>%
  filter(new_date != "") %>%
  .$new_date

active_unwt_ret_roll %>% 
  gather(strategy, ret_3m, -date) %>% 
  mutate(owner = str_extract(strategy, "(?<=:::).*$")) %>%
  arrange(owner, strategy) %>%
  mutate(strategy = factor(strategy, levels = unique(strategy))) %>%
  mutate(date = as.factor(date)) %>%
  ggplot(aes(x = date, y = strategy)) +
  geom_tile(aes(fill = ret_3m)) +
  scale_fill_gradientn(colours = c("#F70000", "#FF4040", "#FA6C6C","white", "lightgreen", "green","darkgreen"),
                       values = rescale(c(c(1, 0.3, 0.1) * min_ret_unwt, 0, c(0.1, 0.3, 1) * max_ret_unwt), to = c(0,1)),
                       labels = scales::percent(c(-0.2, 0, 0.2), accuracy =1),
                       breaks = c(-0.2, 0, 0.2)) +
  scale_x_discrete(labels = date_labels, breaks = recalc_date$factored_date) +
  labs(title = "Unweighted 3m return (% of notional)") +
  theme(legend.position = "bottom", axis.title = element_blank())

```

*Weighted return is assuming current strategy sizes extrapolated into history to calculate the return contribution of each of the strategies based on different periods in history. Consistent light shades of colours across all periods in history could indicate the trade is sized too small for its historical volatility*

```{r display_weighted_returns_timeline, fig.width = 9}

######################################
# Plot heatmap of weighted simulated returns
######################################

# Adjusting x-axis to display dates properly
recalc_date <- sim_ret_roll %>% 
  select(date) %>%
  mutate(yr = year(date), factored_date = as.factor(date)) %>%
  group_by(yr) %>%
  mutate(first_day = min(date)) %>%
  ungroup %>%
  mutate(new_date = ifelse(first_day == date & yr > 1994, sprintf("%02d", yr %% 100), ""),
         row_date = row_number()) %>%
  filter(new_date != "") 

break_positions <- which(recalc_date$new_date != "")
date_labels <- recalc_date %>%
  filter(new_date != "") %>%
  .$new_date

max_ret_wt <- max(remove_date(sim_ret_roll), na.rm = T) * 10000
min_ret_wt <- min(remove_date(sim_ret_roll), na.rm = T) * 10000

sim_ret_roll %>% 
  select(date, active_strategies) %>%
  mutate(date = as.factor(date)) %>%
  gather(strategy, ret_3m, -date) %>%
  mutate(owner = str_extract(strategy, "(?<=:::).*$")) %>%
  arrange(owner, strategy) %>%
  mutate(strategy = factor(strategy, levels = unique(strategy)),
         ret_3m = ret_3m * 10000) %>%  
  ggplot(aes(x = date, y = strategy)) +
  geom_tile(aes(fill = ret_3m)) +
  scale_fill_gradientn(colours = c("#F70000", "#FF4040", "#FA6C6C","white", "lightgreen", "green","darkgreen"),
                       values = rescale(c(c(1, 0.3, 0.1) * min_ret_wt, 0, c(0.1, 0.3, 1) * max_ret_wt), to = c(0,1)),
                       labels = scales::number(c(-10, 0, 10), accuracy =1),
                       breaks = c(-10, 0, 10)) +
  scale_x_discrete(labels = date_labels, breaks = recalc_date$factored_date) +
  labs(title = "Weighted 3m return (bp of R2)") +
  theme(legend.position = "bottom", axis.title = element_blank())
  
```

